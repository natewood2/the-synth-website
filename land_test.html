<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Synthesizer</title>
    <link rel="stylesheet" href="./static/styles.css">
</head>

<body>
    <h1 id="header">the synth website</h1>
    <div id="menu">
        <button id="menuButton" class="dropdown"><span>menu</span></button>
        <div id="menuItems" class="dropdownContent">
            <button class="menuItem dropdown">scenes</button>
            <div id="sceneToggles" class="dropdownContent">
                <button class="toggleButton" id="dayNightToggle">Day/Night</button>
                <button class="toggleButton" id="roomToggle">room</button>
                <button class="toggleButton" id="rainToggle">rain</button>
                <button class="toggleButton" id="snowToggle">snow</button>
                <button class="toggleButton" id="starToggle">stars</button>
                <button class="toggleButton" id="spotlightToggle">spotlight</button>
            </div>
            <button class="menuItem dropdown">sequences</button>
            <div id="sequenceToggles" class="dropdownContent">
                <button class="toggleButton" id="rainToggle">fast</button>
                <button class="toggleButton" id="snowToggle">super chill</button>
                <button class="toggleButton" id="spotlightToggle">space vibes</button>
            </div>
        </div>
    </div>
    <script type="module" src="./static/scripts/menu.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.35/Tone.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script type="module">
        import { dayNight } from './static/scripts/dayandnight.js';
        import { menuScenesSelector } from './static/scripts/menu.js';
        import { boundaries } from './static/scripts/room.js';

        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Set initial camera position
        camera.position.set(0, 1.2, 0); // x, y, z
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        renderer.setClearColor(new THREE.Color('skyblue'));


        // Synthesizer setup
        const synth = new Tone.Synth().toDestination();

        // Load texture
        const textureLoader = new THREE.TextureLoader();
        const synthTexture = textureLoader.load('./static/textures/Plastic005_1K-JPG_Color.jpg'); // Replace with your texture file path

        // Scene Effects
        menuScenesSelector(scene);
        dayNight(scene, 'on'); // Set to day time by default

        let synthObj;
        const buttons = [];
        const lights = [];

        // Load the GLTF model
        const loader = new THREE.GLTFLoader();
        // loader.load('./static/assets/cabin.glb', function (gltf) {

        //     // Position the model
        //     const position = { x: 0, y: -2.27, z: 1.3 }; // x = left/right y = -up/+down z = +front/-back
        //     gltf.scene.position.set(position.x, position.y, position.z);

        //     // Rotate the model counterclockwise 90 degrees around the y-axis
        //     gltf.scene.rotation.y = Math.PI / 2;

        //     // Add the scaled and positioned model to the scene
        //     scene.add(gltf.scene);

        //     console.log('Cabin:', gltf);
        // }, undefined, function (error) {
        //     console.error(error);
        // });
        loader.load('./static/assets/synth.glb', function (gltf) {
            // Position the model
            // const position = { x: 0, y: 0, z: 0 };
            //const scale = .2; // Change this value to scale the model
            // gltf.scene.scale.set(scale, scale, scale);
            // gltf.scene.position.set(position.x, position.y, position.z);
            scene.add(gltf.scene);
            synthObj = gltf;

            // Traverse the GLTF scene to find the buttons and lights
            gltf.scene.traverse((child) => {
                if (child.isMesh && child.name.startsWith('button-')) {
                    const index = parseInt(child.name.split('-')[1], 10);
                    child.userData.note = getNoteFromIndex(index);
                    buttons[index] = child;
                }
                if (child.isMesh && child.name.startsWith('light-')) {
                    const index = parseInt(child.name.split('-')[1], 10);
                    lights[index] = child;
                }
                if (child.isMesh && child.name === 'play-button') {
                    child.userData.isPlayButton = true;
                }
            });
            console.log('Buttons:', buttons);
            console.log('Lights:', lights);
        }, undefined, function (error) {
            console.error(error);
        });

        function getNoteFromIndex(index) {
            switch (index) {
                case 1: return 'C4';
                case 2: return 'D4';
                case 3: return 'E4';
                case 4: return 'F4';
                case 5: return 'G4';
                case 6: return 'A4';
                case 7: return 'B4';
                case 8: return 'C5';
                default: return 'C4';
            }
        }

        let noteSequence = [];

        // Create a line geometry for the raycaster visualizer
        const raycasterLineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, -1)
        ]);

        // Create a line material for the raycaster visualizer
        const raycasterLineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });

        // Create the line for the raycaster visualizer
        const raycasterLine = new THREE.Line(raycasterLineGeometry, raycasterLineMaterial);
        scene.add(raycasterLine);

        document.addEventListener('click', function (event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            // Update the raycaster visualizer
            const rayOrigin = raycaster.ray.origin;
            const rayDirection = raycaster.ray.direction.clone().multiplyScalar(10); // Length of the visualizer line
            raycasterLine.geometry.setFromPoints([rayOrigin, rayOrigin.clone().add(rayDirection)]);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                if (intersectedObject.userData.note) {
                    const index = parseInt(intersectedObject.name.split('-')[1], 10);
                    noteSequence.push({ note: intersectedObject.userData.note, index: index - 1 });
                    let buttonColor = intersectedObject.material.color;
                    if (buttonColor.getHex() === 0xff0000) {
                        buttonColor.set(0xFFFFE0);
                    } else {
                        buttonColor.set(0xff0000);
                    }
                    console.log(`Note added: ${intersectedObject.userData.note}, Index: ${index - 1}`);
                }
                if (intersectedObject.userData.isPlayButton) {
                    console.log('Note sequence:', noteSequence);
                    playSequence(noteSequence);
                }
            }
        });

        function playSequence(sequence) {
            console.log('In func');
            let now = Tone.now();

            console.log(lights);
            sequence.forEach((item, index) => {
                const { note, index: buttonIndex } = item;
                const time = now + index * 0.5;
                console.log('In forEach');
                // Schedule note playback
                synth.triggerAttackRelease(note, '8n', time);

                // Schedule light on
                setTimeout(() => {
                    const light = lights[buttonIndex + 1]; // Add 1 to buttonIndex
                    if (light) {
                        light.material.color.set(0xff0000);
                    }
                }, (time - now) * 1000);

                // Schedule light off
                setTimeout(() => {
                    const light = lights[buttonIndex + 1]; // Add 1 to buttonIndex
                    if (light) {
                        light.material.color.set(0x000000);
                    }
                }, (time - now + 0.3) * 1000);
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>
